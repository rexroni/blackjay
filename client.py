import os
import socket
import sys
import json
import stat
import shutil
import sshtunnel
from time import sleep
from watchdog.observers import Observer
import watchdog.events
from watchdog.events import FileSystemEventHandler
from pprint import pprint
from zipfile import ZipFile

from ignore import *
from metadata import *
from file_encryption import *
from networking import *
from config import get_config

g_ip = '127.0.0.1'
g_po = 0

# here, (push, pull, conflicts) is generated by comparing local and remote metadata
def prep_client_to_server_archive(push, pull, conflicts):
    # now prep the zip archive
    with ZipFile('.blackjay/c2s.zip','w') as z:
        z.writestr('.blackjay/push',json.dumps(push,indent='    '))
        z.writestr('.blackjay/pull',json.dumps(pull,indent='    '))
        z.writestr('.blackjay/conflicts',json.dumps(conflicts,indent='    '))
        for name,meta in push.items():
            if meta['del_flag'] is False:
                z.write(name)

def extract_server_to_client_archive():
    # make the resp directory
    tempdir = '.blackjay/s2c'
    if os.path.exists(tempdir): shutil.rmtree(tempdir)
    os.mkdir(tempdir)
    # extract the zip file
    with ZipFile(os.path.join('.blackjay/s2c.zip'),'r') as z:
        z.extractall(tempdir)
    push = load_metadata(os.path.join(tempdir,'.blackjay/push'))
    pull = load_metadata(os.path.join(tempdir,'.blackjay/pull'))
    conflicts = load_metadata(os.path.join(tempdir,'.blackjay/conflicts'))
    return push, pull, conflicts

def make_client_updates_live(push,pull,conflicts):
    local_meta = load_metadata('.blackjay/metadata')
    # for pushes which were accepted, update local metadata
    for name,meta in push.items():
        local_meta[name] = meta
    # for pulls which were accepted, move file and update local metadata
    for name,meta in pull.items():
        local_meta[name] = meta
        if meta['del_flag'] is False:
            os.rename(os.path.join('.blackjay/s2c',name),name)
    # for conflicts, move file to conflict-styled name
    for name,meta in conflicts.items():
        local_meta[name] = meta
        cname = conflict_name(name)
        os.rename(os.path.join('.blackjay/s2c',name),cname)
        # make file read-only
        mode = os.stat(cname).st_mode
        os.chmod(cname, mode & ~(stat.S_IWUSR | stat.S_IWGRP | stat.S_IWOTH))
    write_metadata(local_meta,'.blackjay/metadata')

def cleanup_client_temp_files():
    os.remove('.blackjay/c2s.zip')
    os.remove('.blackjay/s2c.zip')
    shutil.rmtree('.blackjay/s2c')


def get_remote_metadata(ip,port):
    return json.loads(metadata_req(ip,port))

def synchronize(remoteroot,force_pull=False):
    # debounce timeout
    sleep(.3)
    global g_ip, g_po
    local_meta, immediate_updates, any_updates = get_updated_local_metadata()
    # if there's immediate updates (like a new latest md5sum or mtime), save to disk
    if len(immediate_updates) > 0:
        temp_meta = load_metadata('.blackjay/metadata')
        for name,meta_entry in immediate_updates.items():
            temp_meta[name] = meta_entry
        write_metadata(temp_meta,'.blackjay/metadata')
    print('any updates?',any_updates)
    if any_updates is False and force_pull is False: return
    remote_meta = get_remote_metadata(g_ip,g_po)
    push, pull, conflicts = compare_metadata(local_meta,remote_meta)
    print('pushing',push)
    print('pulling',pull)
    print('conflicts',conflicts)
    push = add_hmacs_to_metadata(push, b'password')
    prep_client_to_server_archive(push, pull, conflicts)
    print('pushing update')
    push_update(g_ip,g_po,'.blackjay/c2s.zip')
    # push_update will also recieve the response!
    print('extracting s2c')
    npush, npull, nconfl = extract_server_to_client_archive()
    print('pushing',npush)
    print('pulling',npull)
    print('conflicts',nconfl)
    make_client_updates_live(npush,npull,nconfl)
    cleanup_client_temp_files()

class SyncHandler(FileSystemEventHandler):
    def __init__(self):
        super()
        self.on_modified = self.process
        self.on_deleted = self.process
        self.on_modified = self.process
        self.on_created = self.process

    def process(self, event):
        """
        event.event_type
            'modified' | 'created' | 'moved' | 'deleted'
        event.is_directory
            True | False
        event.src_path
            path/to/observed/file
        """
        # the file will be processed there
        # pprint( (event.src_path, event.event_type) ) # print now only for degug

        if type(event) == watchdog.events.DirModifiedEvent:
            #print('ignoring dir modified event')
            return
        # now skip anything that matches ignore patterns, except deleting a server_version file
        if should_ignore(event.src_path, ['/.*\.server_copy[^/]*']) \
          and event.event_type == 'deleted':
            pass
        elif should_ignore(event.src_path,load_ignore_patterns()):
            #print('ignoring file: ',event.src_path)
            return
        print('syncing due to',event.src_path)
        print('')


if __name__ == "__main__":
    # first form
    if len(sys.argv) == 2:
        os.chdir(sys.argv[1])
    else:
        print('usage:    python client.py <local location>')
        exit(1)

    # load config file
    config = get_config()
    tunnel = sshtunnel.SSHTunnelForwarder(config['host'],
                                              remote_bind_address=('localhost',int(config['port'])))
    if config['host'] != 'localhost':
        print("starting ssh tunnel")
        tunnel.start()
        g_po = tunnel.local_bind_port
        print(tunnel.tunnel_is_up)
    else:
        g_po = config['port']

    # start watching files
    observer = Observer()
    observer.schedule(SyncHandler(), '.', recursive=True)
    observer.start()
    try:
        while True:
            sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()

    #kill the ssh tunnel if it is active
    if tunnel.is_active:
        tunnel.stop()
