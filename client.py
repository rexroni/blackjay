import os
import socket
import sys
import json
import stat
import shutil
from time import sleep
from watchdog.observers import Observer
import watchdog.events
from watchdog.events import FileSystemEventHandler
from pprint import pprint
from zipfile import ZipFile

from ignore import *
from metadata import *
from file_encryption import *
from networking import *

g_ip = '127.0.0.1'
g_po = 12345

# here, (push, pull, conflicts) is generated by comparing local and remote metadata
def prep_client_to_server_archive(push, pull, conflicts, password):
    # now prep the zip archive
    with ZipFile('.blackjay/c2s.zip','w') as z:
        z.writestr('.blackjay/push',json.dumps(push,indent='    '))
        z.writestr('.blackjay/pull',json.dumps(pull,indent='    '))
        z.writestr('.blackjay/conflicts',json.dumps(conflicts,indent='    '))
        for name,meta in push.items():
            if meta['del_flag'] is False:
                iv = gen_iv(name,meta['mtime'])
                tempname = '.blackjay/encrypt.temp'
                encrypt(name,temp,iv,password)
                z.write(tempname,arcname=name)
                os.remove(tempname)

def extract_server_to_client_archive():
    # make the resp directory
    tempdir = '.blackjay/s2c'
    if os.path.exists(tempdir): shutil.rmtree(tempdir)
    os.mkdir(tempdir)
    # extract the zip file
    with ZipFile(os.path.join('.blackjay/s2c.zip'),'r') as z:
        z.extractall(tempdir)
    push = load_metadata(os.path.join(tempdir,'.blackjay/push'))
    pull = load_metadata(os.path.join(tempdir,'.blackjay/pull'))
    conflicts = load_metadata(os.path.join(tempdir,'.blackjay/conflicts'))
    return push, pull, conflicts

def make_client_updates_live(push,pull,conflicts,password):
    local_meta = load_metadata('.blackjay/metadata')
    # for pushes which were accepted, update local metadata
    for name,meta in push.items():
        local_meta[name] = meta
    # for pulls which were accepted, move file and update local metadata
    for name,meta in pull.items():
        local_meta[name] = meta
        if meta['del_flag'] is False:
            tempname = '.blackjay/decrypt.temp'
            iv = gen_iv(name,meta['mtime'])
            decrypt_file(os.path.join('.blackjay/s2c',name),tempname,password)
            # verify hmac before overwriting local file
            if(meta['hmac'] == get_hmac(tempname,password)):
                os.rename(tempname,name)
            else:
                print('----------------------------------------------')
                print('!!!!!!!!!!!!!HMAC DID NOT MATCH!!!!!!!!!!!!!!!')
                print('----------------------------------------------')
    # for conflicts, move file to conflict-styled name
    for name,meta in conflicts.items():
        local_meta[name] = meta
        cname = conflict_name(name)
        tempname = '.blackjay/decrypt.temp'
        iv = gen_iv(name,meta['mtime'])
        decrypt_file(os.path.join('.blackjay/s2c',name),tempname,password)
        # verify hmac before copying to local file
        if(meta['hmac'] == get_hmac(tempname,password)):
            os.rename(tempname,cname)
        else:
            print('----------------------------------------------')
            print('!!!!!!!!!!!!!HMAC DID NOT MATCH!!!!!!!!!!!!!!!')
            print('----------------------------------------------')
        # make file read-only
        mode = os.stat(cname).st_mode
        os.chmod(cname, mode & ~(stat.S_IWUSR | stat.S_IWGRP | stat.S_IWOTH))
    write_metadata(local_meta,'.blackjay/metadata')

def cleanup_client_temp_files():
    os.remove('.blackjay/c2s.zip')
    os.remove('.blackjay/s2c.zip')
    shutil.rmtree('.blackjay/s2c')

def get_remote_metadata(ip,port):
    return json.loads(metadata_req(ip,port))

def synchronize(remoteroot,force_pull=False):
    # debounce timeout
    sleep(.3)
    global g_ip, g_po
    local_meta, immediate_updates, any_updates = get_updated_local_metadata()
    # if there's immediate updates (like a new latest md5sum or mtime), save to disk
    if len(immediate_updates) > 0:
        temp_meta = load_metadata('.blackjay/metadata')
        for name,meta_entry in immediate_updates.items():
            temp_meta[name] = meta_entry
        write_metadata(temp_meta,'.blackjay/metadata')
    print('any updates?',any_updates)
    if any_updates is False and force_pull is False: return
    remote_meta = get_remote_metadata(g_ip,g_po)
    push, pull, conflicts = compare_metadata(local_meta,remote_meta)
    print('pushing',push)
    print('pulling',pull)
    print('conflicts',conflicts)
    push = add_hmacs_to_metadata(push, b'password')
    prep_client_to_server_archive(push, pull, conflicts)
    print('pushing update')
    push_update(g_ip,g_po,'.blackjay/c2s.zip')
    # push_update will also recieve the response!
    print('extracting s2c')
    npush, npull, nconfl = extract_server_to_client_archive()
    print('pushing',npush)
    print('pulling',npull)
    print('conflicts',nconfl)
    make_client_updates_live(npush,npull,nconfl)
    cleanup_client_temp_files()

class SyncHandler(FileSystemEventHandler):
    def __init__(self, remotepath):
        super()
        self.remotepath = remotepath
        self.on_modified = self.process
        self.on_deleted = self.process
        self.on_modified = self.process
        self.on_created = self.process

    def process(self, event):
        """
        event.event_type
            'modified' | 'created' | 'moved' | 'deleted'
        event.is_directory
            True | False
        event.src_path
            path/to/observed/file
        """
        # the file will be processed there
        # pprint( (event.src_path, event.event_type) ) # print now only for degug

        if type(event) == watchdog.events.DirModifiedEvent:
            #print('ignoring dir modified event')
            return
        # now skip anything that matches ignore patterns, except deleting a server_version file
        if should_ignore(event.src_path, ['/.*\.server_copy[^/]*']) \
          and event.event_type == 'deleted':
            pass
        elif should_ignore(event.src_path,load_ignore_patterns()):
            #print('ignoring file: ',event.src_path)
            return
        print('syncing due to',event.src_path)
        synchronize(self.remotepath)
        print('sync finished')
        print('')


if __name__ == "__main__":
    # first form
    remotepath = ''
    if len(sys.argv) == 2:
        remotepath = os.path.abspath(sys.argv[1])
    # second form
    elif len(sys.argv) == 3:
        remotepath = os.path.abspath(sys.argv[2])
        os.chdir(sys.argv[1])
    else:
        print('usage:    python daemon.py <server location>')
        print('          python daemon.py <local location> <server location>')
        exit(1)

    # check for startup situations
    if os.path.isdir('.blackjay') is not True:
        if len(os.listdir()) == 0:
            print('looks like a new installation.  Initializing...')
            os.mkdir('.blackjay')
            open('.blackjay/metadata','a').close()
            # start with sane defaults in ignore file
            ignf = open('.blackjay/ignore','w')
            ignf.write(default_ignore_file)
            ignf.close()
        else:
            print('looks like restoring an old installation...')
            print('... I don\'t know how to do that yet!!')
            exit(1)

    # start watching files
    observer = Observer()
    observer.schedule(SyncHandler(remotepath), '.', recursive=True)
    observer.start()
    try:
        while True:
            sleep(1)
    except KeyboardInterrupt:
        observer.stop()
    observer.join()
